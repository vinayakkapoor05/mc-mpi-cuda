#include <mpi.h>
#include <cuda_runtime.h>
#include "monte_carlo.h"
#include "kernels.h"


static float *d_x = nullptr;
static float *d_y = nullptr;
static int *d_in = nullptr;
static int *h_in = nullptr;

static const int NUM_POINTS = 1000000;

__global__ void pi_estimator_kernel(float *x, float *y, int *inside, int num_points){
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < num_points){
        float dx = x[idx];
        float dy = y[idx];
        inside[idx] = (dx*dx + dy*dy <= 1.0f);
    }
}

void monte_carlo_kernel(int rank, int size){
    // copies the host buffers generated by generate_random_numbers() into device memory
    cudaMalloc((void**)&d_x, NUM_POINTS * sizeof(float));
    cudaMalloc((void**)&d_y, NUM_POINTS * sizeof(float));
    cudaMalloc((void**)&d_in, NUM_POINTS * sizeof(int));

    h_in = (int*)malloc(NUM_POINTS * sizeof(int));

    // h_global_x and h_global_y were broadcasted by the main process to worker processes
    extern float *h_global_x;
    extern float *h_global_y;

    cudaMemcpy(d_x, h_global_x, NUM_POINTS *  sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(d_y, h_global_y, NUM_POINTS *  sizeof(float), cudaMemcpyHostToDevice);


    // launch kernel

    int threads = 256;
    int blocks = (NUM_POINTS + threads - 1) / threads;

    pi_estimator_kernel<<<blocks, threads>>>(d_x, d_y, d_in, NUM_POINTS);

    // copy back
    cudaMemcpy(h_in, d_in, NUM_POINTS * sizeof(int), cudaMemcpyDeviceToHost);

    // count the points "inside" locally

    long long count_inside = 0;
    for (int i = 0; i < NUM_POINTS; i++){
        count_inside += h_in[i];
    }


    extern long long local_inside;
    local_inside = count_inside;


    cudaFree(d_x);
    cudaFree(d_y);
    cudaFree(d_in);
    free(h_in);
}